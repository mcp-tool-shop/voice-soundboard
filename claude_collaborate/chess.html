<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Workshop</title>
    <style>
        :root {
            --bg-dark: #1a1612;
            --bg-panel: rgba(26, 22, 18, 0.95);
            --border: rgba(139, 115, 85, 0.3);
            --text: #e8e4dc;
            --text-dim: #9a9080;
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --light-square-highlight: #f7ec8a;
            --dark-square-highlight: #dbc34a;
            --selected: rgba(32, 178, 170, 0.5);
            --valid-move: rgba(32, 178, 170, 0.4);
            --last-move-light: #cdd26a;
            --last-move-dark: #aaa23a;
            --check: rgba(255, 0, 0, 0.5);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Georgia', serif;
            background: var(--bg-dark);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            background-image:
                radial-gradient(ellipse at top, rgba(139, 115, 85, 0.1) 0%, transparent 50%),
                radial-gradient(ellipse at bottom, rgba(70, 55, 40, 0.2) 0%, transparent 50%);
        }

        /* Header */
        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 24px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 1.2rem;
            font-weight: 500;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .crown-icon {
            font-size: 1.4rem;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .btn {
            padding: 8px 16px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: transparent;
            color: var(--text);
            font-family: inherit;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn:hover {
            background: rgba(139, 115, 85, 0.2);
            border-color: rgba(139, 115, 85, 0.5);
        }

        .btn-primary {
            background: rgba(139, 115, 85, 0.3);
        }

        /* Main Layout */
        .main {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 30px;
            gap: 40px;
        }

        /* Chess Board Container */
        .board-container {
            position: relative;
        }

        /* Coordinates */
        .coordinates {
            position: absolute;
            font-size: 0.7rem;
            color: var(--text-dim);
            font-weight: 500;
        }

        .file-coords {
            display: flex;
            justify-content: space-around;
            width: 100%;
            left: 0;
        }

        .file-coords.top { top: -20px; }
        .file-coords.bottom { bottom: -20px; }

        .rank-coords {
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            height: 100%;
            top: 0;
        }

        .rank-coords.left { left: -20px; }
        .rank-coords.right { right: -20px; }

        .coord {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Chess Board */
        .board {
            display: grid;
            grid-template-columns: repeat(8, 60px);
            grid-template-rows: repeat(8, 60px);
            border: 8px solid #5d4e37;
            border-radius: 4px;
            box-shadow:
                0 8px 30px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(0, 0, 0, 0.1);
            background: #5d4e37;
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            position: relative;
            transition: background-color 0.15s;
        }

        .square.light {
            background: var(--light-square);
        }

        .square.dark {
            background: var(--dark-square);
        }

        .square.selected.light {
            background: var(--light-square-highlight);
        }

        .square.selected.dark {
            background: var(--dark-square-highlight);
        }

        .square.last-move.light {
            background: var(--last-move-light);
        }

        .square.last-move.dark {
            background: var(--last-move-dark);
        }

        .square.check {
            background: radial-gradient(circle, var(--check) 0%, transparent 70%);
        }

        /* Valid move indicator */
        .square.valid-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.15);
        }

        .square.valid-capture::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 4px solid rgba(0, 0, 0, 0.15);
            box-sizing: border-box;
        }

        /* Pieces */
        .piece {
            font-size: 42px;
            line-height: 1;
            cursor: grab;
            user-select: none;
            filter: drop-shadow(2px 4px 3px rgba(0, 0, 0, 0.4));
            transition: transform 0.1s, filter 0.15s;
            z-index: 1;
        }

        .piece:hover {
            transform: scale(1.08);
            filter: drop-shadow(3px 6px 5px rgba(0, 0, 0, 0.5));
        }

        .piece.dragging {
            cursor: grabbing;
            transform: scale(1.15);
            filter: drop-shadow(5px 10px 8px rgba(0, 0, 0, 0.6));
            z-index: 100;
        }

        .piece.white {
            color: #fff;
            text-shadow:
                0 0 1px #000,
                0 0 2px rgba(0,0,0,0.5);
        }

        .piece.black {
            color: #2a2a2a;
        }

        /* Side Panel */
        .panel {
            width: 280px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }

        .panel-section {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .panel-section:last-child {
            border-bottom: none;
        }

        .panel-title {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-dim);
            margin-bottom: 12px;
        }

        /* Player Info */
        .player-info {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .player-info.active {
            background: rgba(139, 115, 85, 0.3);
            border-left: 3px solid #b58863;
        }

        .player-avatar {
            width: 36px;
            height: 36px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.3rem;
        }

        .player-avatar.white { background: #e8e4dc; }
        .player-avatar.black { background: #3a3530; }

        .player-name {
            font-size: 0.9rem;
            font-weight: 500;
        }

        .player-time {
            font-size: 0.8rem;
            color: var(--text-dim);
            font-family: 'Monaco', monospace;
        }

        /* Move History */
        .move-history {
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.8rem;
        }

        .move-row {
            display: flex;
            padding: 6px 0;
            border-bottom: 1px solid rgba(139, 115, 85, 0.1);
        }

        .move-number {
            width: 30px;
            color: var(--text-dim);
        }

        .move {
            flex: 1;
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 3px;
        }

        .move:hover {
            background: rgba(139, 115, 85, 0.2);
        }

        .move.current {
            background: rgba(139, 115, 85, 0.3);
        }

        /* Captured Pieces */
        .captured {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            min-height: 30px;
        }

        .captured-piece {
            font-size: 1.2rem;
            opacity: 0.7;
        }

        /* Status Message */
        .status {
            text-align: center;
            padding: 12px;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
        }

        .status.check {
            background: rgba(255, 100, 100, 0.2);
            color: #ff9999;
        }

        .status.checkmate {
            background: rgba(255, 215, 0, 0.2);
            color: #ffd700;
            font-weight: 600;
        }

        /* Animations */
        @keyframes piecePlace {
            0% { transform: scale(1.2); }
            50% { transform: scale(0.95); }
            100% { transform: scale(1); }
        }

        .piece.placed {
            animation: piecePlace 0.2s ease-out;
        }

        /* Scrollbar */
        .move-history::-webkit-scrollbar {
            width: 6px;
        }

        .move-history::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 3px;
        }

        .move-history::-webkit-scrollbar-thumb {
            background: rgba(139, 115, 85, 0.3);
            border-radius: 3px;
        }

        /* Promotion Modal */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.active {
            display: flex;
        }

        .promotion-modal {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
        }

        .promotion-modal h3 {
            margin-bottom: 16px;
            font-weight: 500;
        }

        .promotion-options {
            display: flex;
            gap: 10px;
        }

        .promotion-option {
            width: 60px;
            height: 60px;
            background: var(--light-square);
            border: 2px solid var(--border);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .promotion-option:hover {
            transform: scale(1.1);
            border-color: #b58863;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>
            <span class="crown-icon">&#9818;</span>
            Chess Workshop
        </h1>
        <div class="header-actions">
            <button class="btn" onclick="flipBoard()">Flip Board</button>
            <button class="btn" onclick="undoMove()">Undo</button>
            <button class="btn btn-primary" onclick="newGame()">New Game</button>
        </div>
    </header>

    <main class="main">
        <div class="board-container">
            <div class="coordinates file-coords top">
                <span class="coord">a</span>
                <span class="coord">b</span>
                <span class="coord">c</span>
                <span class="coord">d</span>
                <span class="coord">e</span>
                <span class="coord">f</span>
                <span class="coord">g</span>
                <span class="coord">h</span>
            </div>
            <div class="coordinates rank-coords left">
                <span class="coord">8</span>
                <span class="coord">7</span>
                <span class="coord">6</span>
                <span class="coord">5</span>
                <span class="coord">4</span>
                <span class="coord">3</span>
                <span class="coord">2</span>
                <span class="coord">1</span>
            </div>
            <div class="board" id="board"></div>
            <div class="coordinates rank-coords right">
                <span class="coord">8</span>
                <span class="coord">7</span>
                <span class="coord">6</span>
                <span class="coord">5</span>
                <span class="coord">4</span>
                <span class="coord">3</span>
                <span class="coord">2</span>
                <span class="coord">1</span>
            </div>
            <div class="coordinates file-coords bottom">
                <span class="coord">a</span>
                <span class="coord">b</span>
                <span class="coord">c</span>
                <span class="coord">d</span>
                <span class="coord">e</span>
                <span class="coord">f</span>
                <span class="coord">g</span>
                <span class="coord">h</span>
            </div>
        </div>

        <div class="panel">
            <div class="panel-section">
                <div class="player-info black" id="player-black">
                    <div class="player-avatar black">&#9818;</div>
                    <div>
                        <div class="player-name">Black</div>
                        <div class="player-time">--:--</div>
                    </div>
                </div>
                <div class="player-info white active" id="player-white">
                    <div class="player-avatar white">&#9812;</div>
                    <div>
                        <div class="player-name">White</div>
                        <div class="player-time">--:--</div>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Captured</div>
                <div class="captured" id="captured-white"></div>
                <div class="captured" id="captured-black" style="margin-top: 8px;"></div>
            </div>

            <div class="panel-section">
                <div class="panel-title">Moves</div>
                <div class="move-history" id="move-history"></div>
            </div>

            <div class="panel-section">
                <div class="status" id="status">White to move</div>
            </div>
        </div>
    </main>

    <!-- Promotion Modal -->
    <div class="modal-overlay" id="promotion-modal">
        <div class="promotion-modal">
            <h3>Choose promotion</h3>
            <div class="promotion-options" id="promotion-options"></div>
        </div>
    </div>

    <script>
        // Chess piece unicode characters
        const PIECES = {
            K: { white: '\u2654', black: '\u265A', name: 'King' },
            Q: { white: '\u2655', black: '\u265B', name: 'Queen' },
            R: { white: '\u2656', black: '\u265C', name: 'Rook' },
            B: { white: '\u2657', black: '\u265D', name: 'Bishop' },
            N: { white: '\u2658', black: '\u265E', name: 'Knight' },
            P: { white: '\u2659', black: '\u265F', name: 'Pawn' }
        };

        // Initial board state
        const INITIAL_BOARD = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['.', '.', '.', '.', '.', '.', '.', '.'],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // Game state
        let board = [];
        let turn = 'white';
        let selectedSquare = null;
        let validMoves = [];
        let lastMove = null;
        let moveHistory = [];
        let capturedPieces = { white: [], black: [] };
        let castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
        let enPassantTarget = null;
        let flipped = false;

        // DOM elements
        const boardEl = document.getElementById('board');
        const moveHistoryEl = document.getElementById('move-history');
        const statusEl = document.getElementById('status');
        const promotionModal = document.getElementById('promotion-modal');
        const promotionOptions = document.getElementById('promotion-options');

        // Initialize
        function init() {
            board = INITIAL_BOARD.map(row => [...row]);
            turn = 'white';
            selectedSquare = null;
            validMoves = [];
            lastMove = null;
            moveHistory = [];
            capturedPieces = { white: [], black: [] };
            castlingRights = { white: { kingside: true, queenside: true }, black: { kingside: true, queenside: true } };
            enPassantTarget = null;
            renderBoard();
            updateStatus();
            updateMoveHistory();
            updateCaptured();
        }

        // Render the chess board
        function renderBoard() {
            boardEl.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const displayRow = flipped ? 7 - row : row;
                    const displayCol = flipped ? 7 - col : col;

                    const square = document.createElement('div');
                    const isLight = (displayRow + displayCol) % 2 === 0;
                    square.className = `square ${isLight ? 'light' : 'dark'}`;
                    square.dataset.row = displayRow;
                    square.dataset.col = displayCol;

                    // Last move highlight
                    if (lastMove) {
                        if ((displayRow === lastMove.from.row && displayCol === lastMove.from.col) ||
                            (displayRow === lastMove.to.row && displayCol === lastMove.to.col)) {
                            square.classList.add('last-move');
                        }
                    }

                    // Selected square
                    if (selectedSquare && selectedSquare.row === displayRow && selectedSquare.col === displayCol) {
                        square.classList.add('selected');
                    }

                    // Valid moves
                    if (validMoves.some(m => m.row === displayRow && m.col === displayCol)) {
                        const piece = board[displayRow][displayCol];
                        if (piece !== '.') {
                            square.classList.add('valid-capture');
                        } else {
                            square.classList.add('valid-move');
                        }
                    }

                    // Add piece
                    const piece = board[displayRow][displayCol];
                    if (piece !== '.') {
                        const pieceEl = document.createElement('span');
                        const isWhite = piece === piece.toUpperCase();
                        const pieceType = piece.toUpperCase();
                        pieceEl.className = `piece ${isWhite ? 'white' : 'black'}`;
                        pieceEl.textContent = PIECES[pieceType][isWhite ? 'white' : 'black'];
                        pieceEl.draggable = true;

                        pieceEl.addEventListener('dragstart', (e) => onDragStart(e, displayRow, displayCol));
                        pieceEl.addEventListener('dragend', onDragEnd);

                        square.appendChild(pieceEl);

                        // Check indicator
                        if (pieceType === 'K' && isInCheck(isWhite ? 'white' : 'black')) {
                            square.classList.add('check');
                        }
                    }

                    square.addEventListener('click', () => onSquareClick(displayRow, displayCol));
                    square.addEventListener('dragover', (e) => e.preventDefault());
                    square.addEventListener('drop', (e) => onDrop(e, displayRow, displayCol));

                    boardEl.appendChild(square);
                }
            }
        }

        // Get piece color
        function getPieceColor(piece) {
            if (piece === '.') return null;
            return piece === piece.toUpperCase() ? 'white' : 'black';
        }

        // Get valid moves for a piece
        function getValidMoves(row, col) {
            const piece = board[row][col];
            if (piece === '.') return [];

            const color = getPieceColor(piece);
            const pieceType = piece.toUpperCase();
            let moves = [];

            switch (pieceType) {
                case 'P':
                    moves = getPawnMoves(row, col, color);
                    break;
                case 'R':
                    moves = getSlidingMoves(row, col, color, [[0,1],[0,-1],[1,0],[-1,0]]);
                    break;
                case 'N':
                    moves = getKnightMoves(row, col, color);
                    break;
                case 'B':
                    moves = getSlidingMoves(row, col, color, [[1,1],[1,-1],[-1,1],[-1,-1]]);
                    break;
                case 'Q':
                    moves = getSlidingMoves(row, col, color, [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]]);
                    break;
                case 'K':
                    moves = getKingMoves(row, col, color);
                    break;
            }

            // Filter out moves that leave king in check
            return moves.filter(move => !wouldBeInCheck(row, col, move.row, move.col, color));
        }

        function getPawnMoves(row, col, color) {
            const moves = [];
            const direction = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;

            // Forward move
            if (board[row + direction]?.[col] === '.') {
                moves.push({ row: row + direction, col });
                // Double move from starting position
                if (row === startRow && board[row + 2 * direction][col] === '.') {
                    moves.push({ row: row + 2 * direction, col });
                }
            }

            // Captures
            for (const dc of [-1, 1]) {
                const newCol = col + dc;
                if (newCol >= 0 && newCol < 8) {
                    const target = board[row + direction]?.[newCol];
                    if (target && target !== '.' && getPieceColor(target) !== color) {
                        moves.push({ row: row + direction, col: newCol });
                    }
                    // En passant
                    if (enPassantTarget && enPassantTarget.row === row + direction && enPassantTarget.col === newCol) {
                        moves.push({ row: row + direction, col: newCol, enPassant: true });
                    }
                }
            }

            return moves;
        }

        function getKnightMoves(row, col, color) {
            const moves = [];
            const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];

            for (const [dr, dc] of offsets) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = board[newRow][newCol];
                    if (target === '.' || getPieceColor(target) !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            return moves;
        }

        function getSlidingMoves(row, col, color, directions) {
            const moves = [];

            for (const [dr, dc] of directions) {
                let newRow = row + dr;
                let newCol = col + dc;

                while (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = board[newRow][newCol];
                    if (target === '.') {
                        moves.push({ row: newRow, col: newCol });
                    } else {
                        if (getPieceColor(target) !== color) {
                            moves.push({ row: newRow, col: newCol });
                        }
                        break;
                    }
                    newRow += dr;
                    newCol += dc;
                }
            }

            return moves;
        }

        function getKingMoves(row, col, color) {
            const moves = [];
            const directions = [[0,1],[0,-1],[1,0],[-1,0],[1,1],[1,-1],[-1,1],[-1,-1]];

            for (const [dr, dc] of directions) {
                const newRow = row + dr;
                const newCol = col + dc;
                if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                    const target = board[newRow][newCol];
                    if (target === '.' || getPieceColor(target) !== color) {
                        moves.push({ row: newRow, col: newCol });
                    }
                }
            }

            // Castling
            if (!isInCheck(color)) {
                const homeRow = color === 'white' ? 7 : 0;
                if (row === homeRow && col === 4) {
                    // Kingside
                    if (castlingRights[color].kingside &&
                        board[homeRow][5] === '.' && board[homeRow][6] === '.' &&
                        !isSquareAttacked(homeRow, 5, color) && !isSquareAttacked(homeRow, 6, color)) {
                        moves.push({ row: homeRow, col: 6, castle: 'kingside' });
                    }
                    // Queenside
                    if (castlingRights[color].queenside &&
                        board[homeRow][1] === '.' && board[homeRow][2] === '.' && board[homeRow][3] === '.' &&
                        !isSquareAttacked(homeRow, 2, color) && !isSquareAttacked(homeRow, 3, color)) {
                        moves.push({ row: homeRow, col: 2, castle: 'queenside' });
                    }
                }
            }

            return moves;
        }

        function isSquareAttacked(row, col, defendingColor) {
            const attackingColor = defendingColor === 'white' ? 'black' : 'white';

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece !== '.' && getPieceColor(piece) === attackingColor) {
                        const pieceType = piece.toUpperCase();
                        let canAttack = false;

                        if (pieceType === 'P') {
                            const direction = attackingColor === 'white' ? -1 : 1;
                            if (r + direction === row && (c - 1 === col || c + 1 === col)) {
                                canAttack = true;
                            }
                        } else if (pieceType === 'N') {
                            const dr = Math.abs(row - r);
                            const dc = Math.abs(col - c);
                            if ((dr === 2 && dc === 1) || (dr === 1 && dc === 2)) {
                                canAttack = true;
                            }
                        } else if (pieceType === 'K') {
                            if (Math.abs(row - r) <= 1 && Math.abs(col - c) <= 1) {
                                canAttack = true;
                            }
                        } else {
                            // Sliding pieces
                            let dirs = [];
                            if (pieceType === 'R' || pieceType === 'Q') {
                                dirs.push(...[[0,1],[0,-1],[1,0],[-1,0]]);
                            }
                            if (pieceType === 'B' || pieceType === 'Q') {
                                dirs.push(...[[1,1],[1,-1],[-1,1],[-1,-1]]);
                            }

                            for (const [dr, dc] of dirs) {
                                let nr = r + dr;
                                let nc = c + dc;
                                while (nr >= 0 && nr < 8 && nc >= 0 && nc < 8) {
                                    if (nr === row && nc === col) {
                                        canAttack = true;
                                        break;
                                    }
                                    if (board[nr][nc] !== '.') break;
                                    nr += dr;
                                    nc += dc;
                                }
                                if (canAttack) break;
                            }
                        }

                        if (canAttack) return true;
                    }
                }
            }

            return false;
        }

        function isInCheck(color) {
            // Find king
            const kingChar = color === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (board[r][c] === kingChar) {
                        return isSquareAttacked(r, c, color);
                    }
                }
            }
            return false;
        }

        function wouldBeInCheck(fromRow, fromCol, toRow, toCol, color) {
            // Make temporary move
            const captured = board[toRow][toCol];
            const piece = board[fromRow][fromCol];
            board[toRow][toCol] = piece;
            board[fromRow][fromCol] = '.';

            // Handle en passant capture
            let enPassantCaptured = null;
            if (piece.toUpperCase() === 'P' && enPassantTarget &&
                toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                const captureRow = color === 'white' ? toRow + 1 : toRow - 1;
                enPassantCaptured = board[captureRow][toCol];
                board[captureRow][toCol] = '.';
            }

            const inCheck = isInCheck(color);

            // Restore board
            board[fromRow][fromCol] = piece;
            board[toRow][toCol] = captured;
            if (enPassantCaptured !== null) {
                const captureRow = color === 'white' ? toRow + 1 : toRow - 1;
                board[captureRow][toCol] = enPassantCaptured;
            }

            return inCheck;
        }

        function hasLegalMoves(color) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (getPieceColor(board[r][c]) === color) {
                        if (getValidMoves(r, c).length > 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Event handlers
        function onSquareClick(row, col) {
            const piece = board[row][col];

            if (selectedSquare) {
                // Try to make a move
                const move = validMoves.find(m => m.row === row && m.col === col);
                if (move) {
                    makeMove(selectedSquare.row, selectedSquare.col, row, col, move);
                    return;
                }
            }

            // Select a piece
            if (piece !== '.' && getPieceColor(piece) === turn) {
                selectedSquare = { row, col };
                validMoves = getValidMoves(row, col);
            } else {
                selectedSquare = null;
                validMoves = [];
            }

            renderBoard();
        }

        function onDragStart(e, row, col) {
            const piece = board[row][col];
            if (getPieceColor(piece) !== turn) {
                e.preventDefault();
                return;
            }

            selectedSquare = { row, col };
            validMoves = getValidMoves(row, col);
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            renderBoard();
        }

        function onDragEnd(e) {
            e.target.classList.remove('dragging');
        }

        function onDrop(e, toRow, toCol) {
            e.preventDefault();
            if (!selectedSquare) return;

            const move = validMoves.find(m => m.row === toRow && m.col === toCol);
            if (move) {
                makeMove(selectedSquare.row, selectedSquare.col, toRow, toCol, move);
            } else {
                selectedSquare = null;
                validMoves = [];
                renderBoard();
            }
        }

        function makeMove(fromRow, fromCol, toRow, toCol, moveInfo) {
            const piece = board[fromRow][fromCol];
            const captured = board[toRow][toCol];
            const pieceType = piece.toUpperCase();
            const color = getPieceColor(piece);

            // Check for promotion
            if (pieceType === 'P' && (toRow === 0 || toRow === 7)) {
                showPromotionModal(fromRow, fromCol, toRow, toCol, moveInfo);
                return;
            }

            executeMoveInternal(fromRow, fromCol, toRow, toCol, moveInfo);
        }

        function executeMoveInternal(fromRow, fromCol, toRow, toCol, moveInfo, promoteTo = null) {
            const piece = board[fromRow][fromCol];
            const captured = board[toRow][toCol];
            const pieceType = piece.toUpperCase();
            const color = getPieceColor(piece);

            // Record move for notation
            const moveNotation = getMoveNotation(fromRow, fromCol, toRow, toCol, captured, moveInfo, promoteTo);

            // Handle castling
            if (moveInfo.castle) {
                const homeRow = color === 'white' ? 7 : 0;
                if (moveInfo.castle === 'kingside') {
                    board[homeRow][7] = '.';
                    board[homeRow][5] = color === 'white' ? 'R' : 'r';
                } else {
                    board[homeRow][0] = '.';
                    board[homeRow][3] = color === 'white' ? 'R' : 'r';
                }
            }

            // Handle en passant capture
            if (moveInfo.enPassant) {
                const captureRow = color === 'white' ? toRow + 1 : toRow - 1;
                const pawn = board[captureRow][toCol];
                capturedPieces[color].push(pawn.toUpperCase());
                board[captureRow][toCol] = '.';
            }

            // Capture
            if (captured !== '.') {
                capturedPieces[color].push(captured.toUpperCase());
            }

            // Move piece
            board[toRow][toCol] = promoteTo ? (color === 'white' ? promoteTo : promoteTo.toLowerCase()) : piece;
            board[fromRow][fromCol] = '.';

            // Update castling rights
            if (pieceType === 'K') {
                castlingRights[color].kingside = false;
                castlingRights[color].queenside = false;
            }
            if (pieceType === 'R') {
                if (fromCol === 0) castlingRights[color].queenside = false;
                if (fromCol === 7) castlingRights[color].kingside = false;
            }

            // Update en passant target
            if (pieceType === 'P' && Math.abs(toRow - fromRow) === 2) {
                enPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
            } else {
                enPassantTarget = null;
            }

            // Record last move
            lastMove = { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };

            // Record move history
            moveHistory.push({
                notation: moveNotation,
                from: { row: fromRow, col: fromCol },
                to: { row: toRow, col: toCol }
            });

            // Switch turn
            turn = turn === 'white' ? 'black' : 'white';

            // Clear selection
            selectedSquare = null;
            validMoves = [];

            // Update UI
            renderBoard();
            updateStatus();
            updateMoveHistory();
            updateCaptured();

            // Add placement animation
            setTimeout(() => {
                const squares = document.querySelectorAll('.square');
                squares.forEach(sq => {
                    if (parseInt(sq.dataset.row) === toRow && parseInt(sq.dataset.col) === toCol) {
                        const pieceEl = sq.querySelector('.piece');
                        if (pieceEl) pieceEl.classList.add('placed');
                    }
                });
            }, 10);
        }

        function getMoveNotation(fromRow, fromCol, toRow, toCol, captured, moveInfo, promoteTo) {
            if (moveInfo.castle) {
                return moveInfo.castle === 'kingside' ? 'O-O' : 'O-O-O';
            }

            const piece = board[fromRow][fromCol];
            const pieceType = piece.toUpperCase();
            const files = 'abcdefgh';
            const ranks = '87654321';

            let notation = '';

            if (pieceType !== 'P') {
                notation += pieceType;
            }

            // Add disambiguation if needed
            // (simplified - just add file for now)
            if (pieceType !== 'P') {
                notation += files[fromCol];
            }

            if (captured !== '.' || moveInfo.enPassant) {
                if (pieceType === 'P') {
                    notation += files[fromCol];
                }
                notation += 'x';
            }

            notation += files[toCol] + ranks[toRow];

            if (promoteTo) {
                notation += '=' + promoteTo;
            }

            return notation;
        }

        function showPromotionModal(fromRow, fromCol, toRow, toCol, moveInfo) {
            const color = getPieceColor(board[fromRow][fromCol]);

            promotionOptions.innerHTML = '';
            ['Q', 'R', 'B', 'N'].forEach(pieceType => {
                const option = document.createElement('div');
                option.className = 'promotion-option';
                option.textContent = PIECES[pieceType][color];
                option.onclick = () => {
                    promotionModal.classList.remove('active');
                    executeMoveInternal(fromRow, fromCol, toRow, toCol, moveInfo, pieceType);
                };
                promotionOptions.appendChild(option);
            });

            promotionModal.classList.add('active');
        }

        function updateStatus() {
            const inCheck = isInCheck(turn);
            const hasLegal = hasLegalMoves(turn);

            // Update player indicators
            document.getElementById('player-white').classList.toggle('active', turn === 'white');
            document.getElementById('player-black').classList.toggle('active', turn === 'black');

            if (!hasLegal) {
                if (inCheck) {
                    statusEl.textContent = `Checkmate! ${turn === 'white' ? 'Black' : 'White'} wins!`;
                    statusEl.className = 'status checkmate';
                } else {
                    statusEl.textContent = 'Stalemate - Draw!';
                    statusEl.className = 'status';
                }
            } else if (inCheck) {
                statusEl.textContent = `${turn.charAt(0).toUpperCase() + turn.slice(1)} is in check!`;
                statusEl.className = 'status check';
            } else {
                statusEl.textContent = `${turn.charAt(0).toUpperCase() + turn.slice(1)} to move`;
                statusEl.className = 'status';
            }
        }

        function updateMoveHistory() {
            moveHistoryEl.innerHTML = '';

            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
                const row = document.createElement('div');
                row.className = 'move-row';

                row.innerHTML = `
                    <span class="move-number">${moveNum}.</span>
                    <span class="move ${i === moveHistory.length - 1 ? 'current' : ''}">${moveHistory[i].notation}</span>
                    ${moveHistory[i + 1] ? `<span class="move ${i + 1 === moveHistory.length - 1 ? 'current' : ''}">${moveHistory[i + 1].notation}</span>` : '<span class="move">...</span>'}
                `;

                moveHistoryEl.appendChild(row);
            }

            moveHistoryEl.scrollTop = moveHistoryEl.scrollHeight;
        }

        function updateCaptured() {
            const pieceOrder = ['Q', 'R', 'B', 'N', 'P'];

            ['white', 'black'].forEach(color => {
                const el = document.getElementById(`captured-${color}`);
                const sorted = [...capturedPieces[color]].sort((a, b) =>
                    pieceOrder.indexOf(a) - pieceOrder.indexOf(b)
                );
                el.innerHTML = sorted.map(p => {
                    const displayColor = color === 'white' ? 'black' : 'white';
                    return `<span class="captured-piece">${PIECES[p][displayColor]}</span>`;
                }).join('');
            });
        }

        // Button actions
        function newGame() {
            init();
        }

        function flipBoard() {
            flipped = !flipped;

            // Update coordinates
            const files = flipped ? 'hgfedcba' : 'abcdefgh';
            const ranks = flipped ? '12345678' : '87654321';

            document.querySelectorAll('.file-coords').forEach(el => {
                el.innerHTML = files.split('').map(f => `<span class="coord">${f}</span>`).join('');
            });

            document.querySelectorAll('.rank-coords').forEach(el => {
                el.innerHTML = ranks.split('').map(r => `<span class="coord">${r}</span>`).join('');
            });

            renderBoard();
        }

        function undoMove() {
            if (moveHistory.length === 0) return;
            // For simplicity, just restart the game
            // A full implementation would need to track all game state
            alert('Undo not fully implemented yet. Starting new game.');
            init();
        }

        // Start the game
        init();
    </script>
</body>
</html>
